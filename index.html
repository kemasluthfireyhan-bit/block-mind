<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Block Mind Deluxe â€” 6x6 (Fixed)</title>
<style>
  :root{
    --bg: #f6fbff;
    --panel: #ffffff;
    --muted: #6b7280;
    --cell-empty: #fff;
    --cell-border: #e6f0ff;
    --red: #f94144;
    --yellow: #f9c74f;
    --green: #90be6d;
    --blue: #577590;
    --accent: #2563eb;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: linear-gradient(180deg,var(--bg),#eaf6ff);
    color:#07122b; display:flex; align-items:center; justify-content:center;
    min-height:100vh; padding:18px;
  }
  .wrap{
    width:100%; max-width:1000px; background:var(--panel); border-radius:14px; padding:16px;
    box-shadow: 0 14px 36px rgba(9,30,66,0.08);
  }
  header{ display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; }
  h1{ margin:0; color:var(--accent); font-size:20px; }
  p.lead{ margin:0; color:var(--muted); font-size:13px; }

  .layout{ display:flex; gap:18px; margin-top:12px; flex-wrap:wrap; justify-content:center; }
  main { flex: 1 1 560px; min-width:320px; display:flex; flex-direction:column; align-items:center; gap:12px; }
  aside { width:320px; min-width:260px; display:flex; flex-direction:column; gap:12px; }

  /* Board 6x6 */
  #board {
    display:grid; grid-template-columns: repeat(6, 1fr); gap:8px;
    width: min(520px, 92vw); aspect-ratio:1/1; padding:12px; border-radius:12px;
    background: linear-gradient(180deg,#fff,#f8fbff); border:1px solid var(--cell-border);
    touch-action:none;
  }
  .cell{
    background: var(--cell-empty); border-radius:8px; border:1px solid #f0f6ff;
    display:flex; align-items:center; justify-content:center; font-weight:700; font-size:14px;
    height:100%;
    transition: transform 220ms cubic-bezier(.2,.9,.3,1), opacity 220ms ease;
  }
  .cell.filled { color: #fff; box-shadow: inset 0 -6px 0 rgba(0,0,0,0.06); }

  /* Clearing animation */
  .cell.clearing {
    transform: scale(.2);
    opacity: 0;
    transition: transform 360ms cubic-bezier(.2,.9,.3,1), opacity 360ms ease;
  }

  /* Sidebar preview */
  .panel { background:#fff; padding:12px; border-radius:12px; box-shadow: 0 8px 20px rgba(9,30,66,0.04); }
  .preview { display:flex; gap:12px; justify-content:center; align-items:center; margin-top:10px; }
  .piece {
    width:96px; height:96px; border-radius:10px; background:linear-gradient(180deg,#fbfdff,#eef6ff);
    display:grid; place-items:center; user-select:none; touch-action:none; position:relative; cursor:grab;
  }
  .mini {
    display:grid; grid-template-columns: repeat(6, 10px); gap:6px;
    align-items:center; justify-items:center;
  }
  .mini .dot { width:10px; height:10px; border-radius:3px; background:transparent; }
  .mini .dot.on { box-shadow: 0 2px 6px rgba(2,6,23,0.08); }

  .meta { color:var(--muted); font-size:13px; margin-bottom:6px; }
  .score { font-size:24px; font-weight:800; color:var(--accent); }
  .controls { display:flex; gap:8px; margin-top:10px; justify-content:center; }

  button.btn { background:var(--accent); color:white; border:none; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }
  button.ghost { background:#fff; border:1px solid #e6eefc; color:var(--muted); padding:9px 12px; border-radius:10px; }

  .drag-ghost { position:fixed; pointer-events:none; z-index:9999; transform: translate(-50%,-50%); border-radius:10px; padding:10px; box-shadow: 0 14px 40px rgba(9,30,66,0.12); background:linear-gradient(180deg,#fff,#f4fbff); }

  .status { text-align:center; color:var(--muted); font-size:13px; margin-top:8px; }

  @media (max-width:980px){
    aside{ width:100%; max-width:92vw; }
    .preview .piece { width:78px; height:78px; }
    .mini { grid-template-columns: repeat(6, 8px); gap:5px; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Block Mind Deluxe â€” 6Ã—6 (Fixed)</h1>
        <p class="lead">Tarik blok warna ke papan. Animasi clear + suara pop & bling. Jika tak ada ruang â†’ Game Over.</p>
      </div>
      <div style="text-align:right">
        <div style="font-size:12px;color:var(--muted)">Offline â€¢ Drag & Drop â€¢ Mobile Ready</div>
      </div>
    </header>

    <div class="layout">
      <main>
        <div id="board" aria-label="Papan 6x6"></div>

        <div style="display:flex; gap:12px; align-items:center; justify-content:center; margin-top:6px;">
          <div style="background:#fff; padding:10px 14px; border-radius:10px; box-shadow: 0 8px 20px rgba(9,30,66,0.04); text-align:center;">
            <div style="font-size:12px;color:var(--muted)">Skor</div>
            <div class="score" id="score">0</div>
            <div style="font-size:12px;color:var(--muted); margin-top:6px">Highscore: <span id="highscore">0</span></div>
          </div>

          <div style="display:flex; gap:8px;">
            <button class="btn" id="restart">Restart</button>
            <button class="ghost" id="hint">Hint</button>
            <button class="ghost" id="mute">ðŸ”Š</button>
          </div>
        </div>
      </main>

      <aside>
        <div class="panel">
          <div class="meta">Preview blok â€” tahan & seret ke papan</div>
          <div class="preview" id="preview"></div>
          <div class="status" id="status">Berlangsung</div>
        </div>

        <div class="panel">
          <div class="meta">Kontrol & Tips</div>
          <ol style="margin:8px 0 0 18px; color:var(--muted); font-size:13px">
            <li>Tahan & seret blok dari preview â†’ lepaskan di kotak target.</li>
            <li>Jika tidak muat, blok kembali ke preview.</li>
            <li>Isi baris/kolom penuh untuk menghapus & mendapat poin.</li>
          </ol>
        </div>
      </aside>
    </div>
  </div>

<script>
/* Block Mind Deluxe: 6x6, colored cells, drag & drop, clear animation, WebAudio sounds
   Fixed: checkGameOver runs AFTER clears finish (avoids false Game Over)
*/

// CONFIG
const ROWS = 6, COLS = 6;
const STORAGE_KEY = 'blockmind_deluxe_highscore_v1';
const COLORS = ['#f94144','#f9c74f','#90be6d','#577590'];

// SHAPES
const SHAPES = [
  [[0,0]], [[0,0],[0,1]], [[0,0],[1,0]], [[0,0],[0,1],[1,0],[1,1]],
  [[0,0],[0,1],[0,2]], [[0,0],[1,0],[2,0]], [[0,0],[1,0],[1,1]],
  [[0,0],[1,0],[2,0],[2,1]], [[0,0],[0,1],[0,2],[1,1]], [[1,0],[0,1],[1,1],[1,2],[2,1]]
];

// STATE
let grid = [];
let cells = [];
let pieces = [];
let score = 0;
let highscore = parseInt(localStorage.getItem(STORAGE_KEY) || '0', 10);
let dragging = null;
let audioOn = true;

/* DOM refs */
const boardEl = document.getElementById('board');
const previewEl = document.getElementById('preview');
const scoreEl = document.getElementById('score');
const highscoreEl = document.getElementById('highscore');
const statusEl = document.getElementById('status');
const restartBtn = document.getElementById('restart');
const hintBtn = document.getElementById('hint');
const muteBtn = document.getElementById('mute');

/* WebAudio */
let audioCtx = null;
function ensureAudio(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx = null; } }
function playPop(){ if(!audioOn) return; ensureAudio(); if(!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value=880; g.gain.value=0.001; o.connect(g); g.connect(audioCtx.destination); const now=audioCtx.currentTime; g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0.001,now); g.gain.linearRampToValueAtTime(0.12,now+0.01); g.gain.exponentialRampToValueAtTime(0.001,now+0.25); o.start(now); o.stop(now+0.26); }
function playBling(){ if(!audioOn) return; ensureAudio(); if(!audioCtx) return; const freqs=[880,1320,1760]; const now=audioCtx.currentTime; const gain=audioCtx.createGain(); gain.connect(audioCtx.destination); gain.gain.setValueAtTime(0.001,now); gain.gain.linearRampToValueAtTime(0.14,now+0.02); gain.gain.exponentialRampToValueAtTime(0.001,now+0.6); freqs.forEach(f=>{ const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=f; o.connect(gain); o.start(now); o.stop(now+0.6); }); }
function playGameOver(){ if(!audioOn) return; ensureAudio(); if(!audioCtx) return; const now=audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.value=220; o.connect(g); g.connect(audioCtx.destination); g.gain.setValueAtTime(0.001,now); g.gain.linearRampToValueAtTime(0.18,now+0.05); g.gain.exponentialRampToValueAtTime(0.001,now+0.8); o.start(now); o.stop(now+0.9); }

/* UTIL */
function cloneShape(s){ return s.map(p=>[p[0],p[1]]); }
function normalize(s){ const minR=Math.min(...s.map(p=>p[0])), minC=Math.min(...s.map(p=>p[1])); return s.map(p=>[p[0]-minR,p[1]-minC]); }
function randShape(){ return normalize(cloneShape(SHAPES[Math.floor(Math.random()*SHAPES.length)])); }
function randColor(){ return COLORS[Math.floor(Math.random()*COLORS.length)]; }
function uid(){ return Math.random().toString(36).slice(2,9); }

/* INIT BOARD */
function initBoard(){
  grid = Array.from({length:ROWS}, ()=> Array(COLS).fill(null));
  boardEl.innerHTML = '';
  cells = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const el = document.createElement('div');
      el.className = 'cell';
      el.dataset.r = r; el.dataset.c = c;
      boardEl.appendChild(el);
      cells.push(el);
    }
  }
}

/* PREVIEW */
function refillPieces(){
  while(pieces.length < 3) pieces.push({ shape: randShape(), color: randColor(), id: uid() });
  renderPreview();
}
function renderPreview(){
  previewEl.innerHTML = '';
  pieces.forEach((p, idx)=>{
    const box = document.createElement('div');
    box.className = 'piece';
    box.dataset.idx = idx;
    const mini = document.createElement('div');
    mini.className = 'mini';
    const view = 6;
    const maxR = Math.max(...p.shape.map(s=>s[0])), maxC = Math.max(...p.shape.map(s=>s[1]));
    const offR = Math.floor((view - 1 - maxR)/2), offC = Math.floor((view - 1 - maxC)/2);
    for(let r=0;r<view;r++){
      for(let c=0;c<view;c++){
        const d = document.createElement('div'); d.className = 'dot';
        const cr = r - offR, cc = c - offC;
        if(p.shape.some(s=>s[0]===cr && s[1]===cc)){ d.classList.add('on'); d.style.background = p.color; }
        mini.appendChild(d);
      }
    }
    box.appendChild(mini);
    box.addEventListener('pointerdown', (ev)=> onPointerDown(ev, idx));
    previewEl.appendChild(box);
  });
}

/* DRAG & DROP */
function onPointerDown(ev, previewIndex){
  ev.preventDefault();
  const piece = pieces[previewIndex];
  if(!piece) return;
  const ghost = document.createElement('div');
  ghost.className = 'drag-ghost';
  ghost.style.left = ev.clientX + 'px';
  ghost.style.top = ev.clientY + 'px';
  const mini = document.createElement('div');
  mini.style.display = 'grid'; mini.style.gridTemplateColumns = 'repeat(4,14px)'; mini.style.gap = '6px';
  const view = 4;
  const maxR = Math.max(...piece.shape.map(s=>s[0])), maxC = Math.max(...piece.shape.map(s=>s[1]));
  const offR = Math.floor((view - 1 - maxR)/2), offC = Math.floor((view - 1 - maxC)/2);
  for(let r=0;r<view;r++){
    for(let c=0;c<view;c++){
      const d = document.createElement('div'); d.style.width='14px'; d.style.height='14px'; d.style.borderRadius='3px';
      const cr = r - offR, cc = c - offC;
      if(piece.shape.some(s=>s[0]===cr && s[1]===cc)) d.style.background = piece.color;
      else d.style.background = 'transparent';
      mini.appendChild(d);
    }
  }
  ghost.appendChild(mini);
  document.body.appendChild(ghost);

  dragging = { piece, sourceIndex: previewIndex, ghostEl: ghost };

  moveGhost(ev.clientX, ev.clientY);
  try{ ev.target.setPointerCapture(ev.pointerId); } catch(e){}
  document.addEventListener('pointermove', onMove);
  document.addEventListener('pointerup', onUp);

  function onMove(e){ moveGhost(e.clientX, e.clientY); }
  function onUp(e){
    try{ ev.target.releasePointerCapture(ev.pointerId); } catch(e){}
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
    handleDrop(e.clientX, e.clientY);
  }
}

function moveGhost(x,y){ if(!dragging) return; dragging.ghostEl.style.left = x + 'px'; dragging.ghostEl.style.top = y + 'px'; }

function handleDrop(clientX, clientY){
  if(!dragging) return;
  const el = document.elementFromPoint(clientX, clientY);
  let target = el;
  while(target && !target.classList.contains('cell') && target !== document.body) target = target.parentElement;
  if(target && target.classList.contains('cell')){
    const r = parseInt(target.dataset.r,10), c = parseInt(target.dataset.c,10);
    attemptPlace(dragging.piece, dragging.sourceIndex, r, c);
  }
  dragging.ghostEl.remove();
  dragging = null;
}

/* PLACEMENT */
function canPlace(shape, anchorR, anchorC){
  for(const [dr,dc] of shape){
    const r = anchorR + dr, c = anchorC + dc;
    if(r < 0 || c < 0 || r >= ROWS || c >= COLS) return false;
    if(grid[r][c] !== null) return false;
  }
  return true;
}
function place(shape, anchorR, anchorC, color){
  for(const [dr,dc] of shape){ const r = anchorR + dr, c = anchorC + dc; grid[r][c] = color; }
}

/* attemptPlace now waits for processClears callback before checking game over */
function attemptPlace(pieceObj, sourceIndex, r, c){
  if(!canPlace(pieceObj.shape, r, c)){
    flashInvalid(r,c,pieceObj.shape);
    return;
  }
  place(pieceObj.shape, r, c, pieceObj.color);
  playPop();
  const ix = pieces.findIndex(x => x.id === pieceObj.id);
  if(ix !== -1) pieces.splice(ix,1);
  refillPieces();
  updateBoard();
  // IMPORTANT: check game over only after clears finish (if any)
  processClears(()=> {
    if(checkGameOver()){
      doGameOver();
    }
  });
}

/* UPDATE VISUAL */
function updateBoard(){
  for(const el of cells){
    const r = parseInt(el.dataset.r,10), c = parseInt(el.dataset.c,10);
    const col = grid[r][c];
    if(col){
      el.classList.add('filled');
      el.style.background = col;
      el.style.color = '#fff';
      el.textContent = '';
    } else {
      el.classList.remove('filled');
      el.style.background = '';
      el.textContent = '';
    }
  }
  scoreEl.textContent = score;
  highscoreEl.textContent = highscore;
}

/* flash invalid */
function flashInvalid(anchorR, anchorC, shape){
  const toFlash = [];
  for(const [dr,dc] of shape){
    const r = anchorR + dr, c = anchorC + dc;
    if(r>=0 && c>=0 && r<ROWS && c<COLS){
      const el = cells[r*COLS + c];
      el.style.transform = 'scale(1.06)';
      toFlash.push(el);
    }
  }
  setTimeout(()=> toFlash.forEach(e=> e.style.transform = ''), 180);
}

/* processClears now accepts callback invoked AFTER clears (or immediately if none) */
function processClears(callback){
  const fullRows = [];
  for(let r=0;r<ROWS;r++){ if(grid[r].every(v=>v !== null)) fullRows.push(r); }
  const fullCols = [];
  for(let c=0;c<COLS;c++){
    let ok = true; for(let r=0;r<ROWS;r++) if(grid[r][c] === null){ ok = false; break; }
    if(ok) fullCols.push(c);
  }
  if(fullRows.length === 0 && fullCols.length === 0){
    // nothing to clear â€” call callback immediately
    if(typeof callback === 'function') callback();
    return;
  }

  // mark toClear
  const toClear = new Set();
  fullRows.forEach(r=>{ for(let c=0;c<COLS;c++) toClear.add(r+'-'+c); });
  fullCols.forEach(c=>{ for(let r=0;r<ROWS;r++) toClear.add(r+'-'+c); });

  // add 'clearing' class to trigger CSS animation
  const clearEls = [];
  toClear.forEach(key => {
    const [r,c] = key.split('-').map(Number);
    const el = cells[r*COLS + c];
    el.classList.add('clearing');
    clearEls.push(el);
  });

  // play bling
  playBling();

  // after animation, actually clear and update score, then call callback
  setTimeout(()=>{
    toClear.forEach(key => {
      const [r,c] = key.split('-').map(Number);
      grid[r][c] = null;
    });
    const clearedCount = toClear.size;
    let gained = clearedCount * 15;
    if(fullRows.length + fullCols.length >= 2) gained += (fullRows.length + fullCols.length) * 30;
    score += gained;
    if(score > highscore){ highscore = score; localStorage.setItem(STORAGE_KEY, highscore); }
    // remove clearing classes
    clearEls.forEach(el => el.classList.remove('clearing'));
    updateBoard();
    status(`Bersih ${fullRows.length} baris & ${fullCols.length} kolom! +${gained}`);
    if(typeof callback === 'function') callback();
  }, 380); // slightly longer than CSS duration to be safe
}

/* GAME OVER */
function checkGameOver(){
  for(const p of pieces){
    const shape = p.shape;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(canPlace(shape,r,c)) return false;
      }
    }
  }
  return true;
}
function doGameOver(){
  playGameOver();
  status('Game Over');
  updateBoard();
  setTimeout(()=> { alert('Game Over!\nSkor: ' + score); }, 120);
}

/* HINT */
function showHint(){
  if(pieces.length === 0) return;
  for(let pi=0; pi<pieces.length; pi++){
    const p = pieces[pi];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(canPlace(p.shape, r, c)){
          const els = [];
          p.shape.forEach(([dr,dc])=>{
            const rr = r+dr, cc = c+dc;
            if(rr>=0 && cc>=0 && rr<ROWS && cc<COLS) els.push(cells[rr*COLS + cc]);
          });
          els.forEach(e=> e.style.boxShadow = '0 0 0 8px rgba(37,99,235,0.08) inset');
          setTimeout(()=> els.forEach(e=> e.style.boxShadow = ''), 700);
          return;
        }
      }
    }
  }
  status('Tidak ada tempat untuk blok');
}

/* status */
function status(txt){ statusEl.textContent = txt; setTimeout(()=> statusEl.textContent = 'Berlangsung', 900); }

/* restart */
function restart(){ if(!confirm('Mulai ulang permainan?')) return; score = 0; pieces = []; initBoard(); refillPieces(); updateBoard(); }
restartBtn.addEventListener('click', restart);
hintBtn.addEventListener('click', showHint);
muteBtn.addEventListener('click', ()=> { audioOn = !audioOn; muteBtn.textContent = audioOn ? 'ðŸ”Š' : 'ðŸ”‡'; });

/* setup */
function setup(){ initBoard(); cells = Array.from(boardEl.querySelectorAll('.cell')); pieces = []; refillPieces(); score = 0; highscoreEl.textContent = highscore; updateBoard(); }
setup();

/* prevent scrolling while dragging on mobile */
document.addEventListener('touchmove', (e)=> { if(dragging) e.preventDefault(); }, {passive:false});
</script>
</body>
</html>